// Save API key to .env file
function saveApiKeyToEnv(apiKey) {
  const envPath = path.join(process.cwd(), '.env');
  let envContent = '';
  
  // Check if .env exists and read its content
  if (fs.existsSync(envPath)) {
    envContent = fs.readFileSync(envPath, 'utf8');
    
    // Check if HF_TOKEN already exists in the file
    const envLines = envContent.split('\n');
    let tokenExists = false;
    
    // Create new content with updated token
    const newContent = envLines.map(line => {
      if (line.trim().startsWith('HF_TOKEN=')) {
        tokenExists = true;
        return `HF_TOKEN=${apiKey}`;
      }
      return line;
    }).join('\n');
    
    // If token doesn't exist in file, add it
    if (!tokenExists) {
      envContent = newContent + `\nHF_TOKEN=${apiKey}\n`;
    } else {
      envContent = newContent;
    }
  } else {
    // Create new .env file with token
    envContent = `HF_TOKEN=${apiKey}\n`;
  }
  
  // Write to .env file
  try {
    fs.writeFileSync(envPath, envContent);
    console.log('Hugging Face token saved to .env file');
    return true;
  } catch (error) {
    console.error('Error saving token to .env file:', error.message);
    return false;
  }
}

// Ask for Hugging Face API Token
async function askApiKey() {
  let apiKey = process.env.HF_TOKEN;
  if (!apiKey) {
    const answer = await prompt([
      {
        type: 'input',
        name: 'apiKey',
        message: 'Enter your Hugging Face access token:',
      },
    ]);
    apiKey = answer.apiKey;
    
    // Ask if the user wants to save the token for future use
    const saveAnswer = await prompt([
      {
        type: 'confirm',
        name: 'saveToken',
        message: 'Do you want to save the token for future use?',
        default: true
      },
    ]);
    
    if (saveAnswer.saveToken) {
      saveApiKeyToEnv(apiKey);
    }
  }
  return apiKey;
}

// Generate project structure and Dockerfile using Hugging Face
async function generateWithOpenAI(apiKey, preferences) {
  // Prepare a robust prompt for Hugging Face based on user preferences
  let promptText = `You are an expert project scaffold generator. The user has selected:\n`;
  
  // Add project type
  promptText += `Project Type: ${preferences.projectType} (${preferences.projectType === 'frontend' ? 'Frontend Only' : preferences.projectType === 'backend' ? 'Backend Only' : 'Full Stack'})\n`;
  
  // Add frontend details if applicable
  if (preferences.frontend) {
    promptText += `Frontend: ${preferences.frontend} (${preferences.frontendFramework})\n`;
    promptText += `CSS Framework: ${preferences.cssFramework}\n`;
  }
  
  // Add backend details if applicable
  if (preferences.backend) {
    promptText += `Backend: ${preferences.backend} (${preferences.backendFramework})\n`;
  }
  
  // Standard instructions
  promptText += `\nGenerate a complete, production-ready project template with:
1. All necessary configuration files (package.json, tsconfig.json, etc.) with correct dependencies for the selected technologies.
2. A coherent folder structure${preferences.projectType === 'fullstack' ? ': /frontend, /backend, /docker' : ''}.
3. ${preferences.projectType === 'fullstack' ? 'A Dockerfile compatible with the selected technologies.' : 'Appropriate configuration for development and production.'}
4. A bilingual README.md (EN/IT) with install, usage, and configuration instructions.
5. All necessary config files (.gitignore, .env.example if needed).
6. All code and comments must be bilingual (EN/IT).
7. The template must be immediately installable and runnable with no missing files or dependency errors.
8. Include proper configuration for the selected CSS framework (${preferences.cssFramework}) if applicable.
9. Output all file contents and folder structure, ready to be written to disk.`;

  // Call Hugging Face Inference API with our prompt
  try {
    const response = await axios.post(
      'https://api-inference.huggingface.co/models/gpt2',
      {
        inputs: promptText,
      },
      {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json',
        },
      }
    );
    // Response may be an array of objects with generated_text field
    if (Array.isArray(response.data) && response.data[0]?.generated_text) {
      return response.data[0].generated_text;
    }
    // Handle other response formats
    return JSON.stringify(response.data, null, 2);
  } catch (error) {
    if (error.response && error.response.data) {
      console.error('Hugging Face API error:', JSON.stringify(error.response.data));
    } else {
      console.error('Error calling Hugging Face API:', error.message);
    }
    return null;
  }
}